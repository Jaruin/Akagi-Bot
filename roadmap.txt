handScorer
-input:Hand
-output:Highest Scoring Hand Shape, Total Score, Components of Score(Like which Yakus it earned) or False if not a scoring hand
-steps:
	possibleHands = handFinder(Hand)
	if possibleHands empty: return False
	scores = handScore(x) for each x in possibleHands
	highScore = highestScore(scores)
	return (highScore, possibleHands(index of highScore))

handFinder
-input:Hand
-output:List of objects which contain the melds, the winning tile, and whether the hand was concealed or not
-steps:  
	intialize empty hands[] list
	check for 13 orphans
		if present, just return that alone, skipping the rest
	check for 7 pairs
		hands are ordered, so we can just do like a for loop of length 7 that checks if a tile is equal to the next one.  If present, add to hands[].  Technically possible to have both this and a normal hand, because you could get like 112233445566GG or something, where you have 4 runs and a pair.
	
	Now the trickier part
	Couple of things we can use to make this easier.  One thing is that each suit can't interact at all, so we can break up the hand by suit and find all the permutations and of each suit, instead of having to do recursive stuff for the whole hand.  We can even make the recursive bit faster by checking which suit needs to deal with pairs, and which one's don't, because only one suit won't be divisible by 3, and that's the one which must have the pair.  The rest can't have a pair.  So.
	Step 1:  Break hand up into different suits.
	Step 2:  Find out which suit has the pair.
	Step 3:  Find each combination of possible melds for each suit, making use of the pair info
	Step 4:  Combine the different melds together.  So if pins have like 2 ways of being scored, and sou has 1, and wan has 3, we'd get 6 possible hands returned.  
	I think the number of permutations is not actually that big, and its going to be rare to really have multiple ways to score a hand, so this should be fast most of the time and just return one hand.

getScore
-input:handFinder output object
-output: score, list of where all points come from
	go through each possible source of yaku.  If a given one fits, add it to the list of yakus
	check if this hand has any yaku.  If not, return 0, else, add dora points to yaku and save that number.
	if fu points are needed, go through these points as well, and total fu points
	make a function that takes (yaku+dora, fu) but with fu defaulted in case fu points are not needed.
	return that score, and the list of yakus and fus


I think that's basically it.  There are a couple of weird things we'll need to add to this.  Checking for illegal hands, and the heaven/earth/etc hands.
Also, I think this will run fast enough, that for the purposes of suggesting which tile to discard to go into riichi, or checking if you had a ready hand when the game ties at the end, we can probably, just run this like 34 for each possible additional tile, times to check if a hand is one away from winning.  I did read an article about how to find the distance an arbitrary hand was from winning, which might be useful to implement eventually though in favor of that, especially if we ever actually start making a computer player that actually has to make decisions about the game, or we want to like, tell new players what a good tile to discard would be. 
	